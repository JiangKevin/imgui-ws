<html>
    <head>
        <script src="incppect.js"></script>
    </head>

    <body style="font-family: Georgia, serif;" onload="init()">
        <script>
            var canvas = null;
            var gl = null;

            var shader_program = null;
            var vertex_buffer = null;
            var index_buffer = null;

            var tex_font_id = null;
            var tex_font_abuf = null;

            var has_font = false;

            function init() {
                var output = document.createElement('div');
                document.body.appendChild( output );

                canvas = document.getElementById('canvas_main');
                gl = canvas.getContext('webgl');

                //var vertices = [
                //    -0.5,  0.5,  0.0,
                //    -0.5, -0.5,  0.0,
                //     0.5, -0.5,  0.0, 
                //];

                vertices = [
                    -1.0,  1.0, 0.0, 0.0, 0.125263,
                    -1.0, -1.0, 0.0, 1.0, 0.125263,
                     1.0, -1.0, 1.0, 1.0, 0.125263,
                     1.0,  1.0, 1.0, 0.0, 0.125263,
                ];

                indices = [0,1,2,0,2,3];

                vertex_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ARRAY_BUFFER, null);

                index_buffer = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, null);

                /*================ Shaders ====================*/

                var vertex_shader =
                    'uniform mat4 ProjMtx;' +
                    'attribute vec2 Position;' +
                    'attribute vec2 UV;' +
                    'attribute vec4 Color;' +
                    'varying vec2 Frag_UV;' +
                    'varying vec4 Frag_Color;' +
                    'void main(void) {' +
                    '	Frag_UV = UV;' +
                    '	Frag_Color = Color;' +
                    '   gl_Position = ProjMtx * vec4(Position, 0.0, 1.0);' +
                    '}';

                var vertShader = gl.createShader(gl.VERTEX_SHADER);
                gl.shaderSource(vertShader, vertex_shader);
                gl.compileShader(vertShader);

                var fragment_shader = [
                    'precision mediump float;' +
                    'uniform sampler2D Texture;' +
                    'varying vec2 Frag_UV;' +
                    'varying vec4 Frag_Color;' +
                    'void main() {' +
                    '	gl_FragColor = Frag_Color * texture2D(Texture, Frag_UV);' +
                    '}'
                ];

                var fragShader = gl.createShader(gl.FRAGMENT_SHADER);
                gl.shaderSource(fragShader, fragment_shader); 
                gl.compileShader(fragShader);

                shader_program = gl.createProgram();
                gl.attachShader(shader_program, vertShader);
                gl.attachShader(shader_program, fragShader);
                gl.linkProgram(shader_program);

                g_AttribLocationTex = gl && gl.getUniformLocation(shader_program, "Texture");
                g_AttribLocationProjMtx = gl && gl.getUniformLocation(shader_program, "ProjMtx");
                g_AttribLocationPosition = gl && gl.getAttribLocation(shader_program, "Position") || 0;
                g_AttribLocationUV = gl && gl.getAttribLocation(shader_program, "UV") || 0;
                g_AttribLocationColor = gl && gl.getAttribLocation(shader_program, "Color") || 0;

                incppect.render = function() {
                    if (tex_font_abuf === null || tex_font_abuf.byteLength < 1) {
                        tex_font_abuf = incppect.get_abuf('imgui.textures[%d]', 1);
                        if (tex_font_abuf.byteLength < 1) return;
                        return;
                    }

                    var tex_font_uint8 = new Uint8Array(tex_font_abuf);
                    var tex_font_int32 = new Int32Array(tex_font_abuf);
                    
                    if (has_font == false) {
                        has_font = true;

                        const width = tex_font_int32[2];
                        const height = tex_font_int32[3];

                        var pixels = new Uint8Array(4*width*height);
                        for (var i = 0; i < width*height; ++i) {
                            pixels[4*i + 0] = tex_font_uint8[16 + i];
                            pixels[4*i + 1] = 0xFF;
                            pixels[4*i + 2] = 0xFF;
                            pixels[4*i + 3] = 0xFF;
                        }

                        tex_font_id = gl && gl.createTexture();
                        gl && gl.bindTexture(gl.TEXTURE_2D, tex_font_id);
                        gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                        gl && gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                        // gl && gl.pixelStorei(gl.UNPACK_ROW_LENGTH); // WebGL2
                        gl && gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
                    }

                    var draw_data_abuf = incppect.get_abuf('imgui.draw_data');
                    if (draw_data_abuf.byteLength < 1) return;

                    var draw_data_offset = 0;
                    var draw_data_uint16 = new Uint16Array(draw_data_abuf);
                    var draw_data_uint32 = new Uint32Array(draw_data_abuf);
                    var draw_data_float = new FloatArray(draw_data_abuf);

                    output.innerHTML = '';
                    output.innerHTML += 'Id     = ' + tex_font_int32[0] + '<br>';
                    output.innerHTML += 'Type   = ' + tex_font_int32[1] + '<br>';
                    output.innerHTML += 'Width  = ' + tex_font_int32[2] + '<br>';
                    output.innerHTML += 'Height = ' + tex_font_int32[3] + '<br>';
                    output.innerHTML += 'Cmd lists = ' + draw_data_uint32[0] + '<br>';

                    /*======= Associating shaders to buffer objects =======*/

                    gl && gl.enable(gl.BLEND);
                    gl && gl.blendEquation(gl.FUNC_ADD);
                    gl && gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                    gl && gl.disable(gl.CULL_FACE);
                    gl && gl.disable(gl.DEPTH_TEST);

                    //gl && gl.enable(gl.SCISSOR_TEST);
                    const L = -1.0;
                    const R = 1.0;
                    const T = 1.0;
                    const B = -1.0;

                    const ortho_projection = new Float32Array([
                        2.0 / (R - L), 0.0, 0.0, 0.0,
                        0.0, 2.0 / (T - B), 0.0, 0.0,
                        0.0, 0.0, -1.0, 0.0,
                        (R + L) / (L - R), (T + B) / (B - T), 0.0, 1.0,
                    ]);
                    gl && gl.useProgram(shader_program);
                    gl && gl.uniform1i(g_AttribLocationTex, 0);
                    gl && g_AttribLocationProjMtx && gl.uniformMatrix4fv(g_AttribLocationProjMtx, false, ortho_projection);

                    gl.bindBuffer(gl.ARRAY_BUFFER, vertex_buffer);

                    gl && gl.enableVertexAttribArray(g_AttribLocationPosition);
                    gl && gl.enableVertexAttribArray(g_AttribLocationUV);
                    gl && gl.enableVertexAttribArray(g_AttribLocationColor);
                    gl && gl.vertexAttribPointer(g_AttribLocationPosition, 2, gl.FLOAT,         false, 5*4, 0);
                    gl && gl.vertexAttribPointer(g_AttribLocationUV,       2, gl.FLOAT,         false, 5*4, 2*4);
                    gl && gl.vertexAttribPointer(g_AttribLocationColor,    4, gl.UNSIGNED_BYTE, true,  5*4, 4*4);

                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, index_buffer);

                    /*=========Drawing the triangle===========*/

                    gl.clearColor(0.0, 0.0, 0.0, 1.0);
                    gl.clear(gl.COLOR_BUFFER_BIT);
                    gl.viewport(0,0,canvas.width,canvas.height);
                    gl && gl.activeTexture(gl.TEXTURE0);
                    gl && gl.bindTexture(gl.TEXTURE_2D, tex_font_id);
                    gl.drawElements(gl.TRIANGLES, indices.length, gl.UNSIGNED_SHORT,0);
                }

                incppect.onerror = function(evt) {
                    if (typeof evt === 'object') {
                        output.innerHTML = 'Error: check console for more information';
                        console.error(evt);
                    } else {
                        output.innerHTML = evt;
                    }
                }

                incppect.onopen = function(evt) {
                }

                incppect.init();
            }

        </script>

        <div id=main-container align=center width=900px>
            <br><br>
            <canvas id="canvas_main" width="1024px" height="256px" style="border:1px solid #d3d3d3;">Your browser does not support the HTML5 canvas tag.</canvas>
        </div>
    </body>
</html>
